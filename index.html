<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>1分ドット絵シューティング</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Mono", monospace;
      color: #fff;
      overflow: hidden;
    }
    #game-container {
      position: relative;
    }
    canvas {
      background: #101018;
      image-rendering: pixelated;
      width: 360px;
      height: 640px;
      border: 2px solid #444;
      display: block;
    }
    #ui-overlay {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      text-align: center;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
    #ui-top {
      display: flex;
      justify-content: space-between;
      padding: 0 8px;
      font-size: 14px;
    }
    #message-center {
      margin-top: 8px;
      font-size: 12px;
    }
    .screen {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 16px;
      z-index: 10;
    }
    .screen h1 {
      font-size: 24px;
      margin-bottom: 12px;
    }
    .screen p {
      font-size: 13px;
      line-height: 1.6;
      margin-bottom: 12px;
    }
    .btn {
      margin-top: 8px;
      padding: 8px 20px;
      border-radius: 999px;
      border: 1px solid #0ff;
      background: #022;
      color: #0ff;
      font-size: 14px;
      cursor: pointer;
      pointer-events: auto;
      transition: background 0.1s, transform 0.1s;
    }
    .btn:active {
      transform: translateY(1px);
      background: #044;
    }
    #start-screen, #gameover-screen {
      display: none;
    }
    #start-screen.active, #gameover-screen.active {
      display: flex;
    }
    #hint {
      font-size: 11px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="180" height="320"></canvas>

    <div id="ui-overlay">
      <div id="ui-top">
        <div>TIME: <span id="time">60</span>s</div>
        <div>LV: <span id="level">1</span></div>
        <div>SCORE: <span id="score">0</span></div>
      </div>
      <div id="message-center"></div>
    </div>

    <!-- タイトル画面 -->
    <div id="start-screen" class="screen active">
      <h1>1分ドット絵シューティング</h1>
      <p>
        ・縦画面・片手ドラッグ操作<br>
        ・自機はSFジェット機（画面下寄り）<br>
        ・ゴブリン / スライム / スケルトン / 魔王 を撃破<br>
        ・20体撃破ごとにレベルアップして弾が強化<br>
        ・制限時間は 1 分
      </p>
      <p id="hint">画面をドラッグした位置に自機が移動します。弾は自動で発射されます。</p>
      <button id="start-btn" class="btn">ゲーム開始</button>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="gameover-screen" class="screen">
      <h1>GAME OVER</h1>
      <p>TIME: <span id="final-time">0</span>s<br> SCORE: <span id="final-score">0</span></p>
      <p id="result-message"></p>
      <button id="retry-btn" class="btn">もう一度プレイ</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false; // ドットをくっきり表示

    const timeEl = document.getElementById('time');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const msgEl = document.getElementById('message-center');

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startBtn = document.getElementById('start-btn');
    const retryBtn = document.getElementById('retry-btn');
    const finalTimeEl = document.getElementById('final-time');
    const finalScoreEl = document.getElementById('final-score');
    const resultMsgEl = document.getElementById('result-message');

    // ゲーム状態
    let playing = false;
    let timeLeft = 60;
    let score = 0;
    let lastTime = 0;
    let level = 1;
    let killCount = 0;

    // 自機
    const player = {
      x: canvas.width / 2,
      y: canvas.height - 60, // 少し上に配置して下部バーから離す
      w: 12,
      h: 14
    };

    const bullets = [];
    const enemies = [];
    const effects = [];

    const px = 2; // ドットグリッド

    // レベルごとの弾設定
    const LEVEL_CONFIG = [
      { color: '#ff0', speed: -3.0 }, // Lv1
      { color: '#0ff', speed: -3.8 }, // Lv2
      { color: '#f80', speed: -4.6 }, // Lv3
      { color: '#f0f', speed: -5.4 }  // Lv4以降はこれで固定
    ];
    const BASE_SHOT_INTERVAL = 180; // ms

    function getLevelConfig() {
      const idx = Math.min(level - 1, LEVEL_CONFIG.length - 1);
      return LEVEL_CONFIG[idx];
    }

    // 敵タイプ
    const ENEMY_TYPES = [
      { name: 'goblin',   color: '#3f3', score: 20 },
      { name: 'slime',    color: '#6ff', score: 15 },
      { name: 'skeleton', color: '#fff', score: 25 },
      { name: 'demon',    color: '#f3f', score: 120 }
    ];

    function resetGame() {
      timeLeft = 60;
      score = 0;
      level = 1;
      killCount = 0;
      timeEl.textContent = timeLeft;
      scoreEl.textContent = score;
      levelEl.textContent = level;
      bullets.length = 0;
      enemies.length = 0;
      effects.length = 0;
      player.x = canvas.width / 2;
      player.y = canvas.height - 60;
      lastTime = performance.now();
      msgEl.textContent = '';
    }

    // 自機描画（解像度上げたジェット機）
    function drawPlayer() {
      const baseX = Math.round(player.x / px) * px;
      const baseY = Math.round(player.y / px) * px;

      // 機体本体
      ctx.fillStyle = '#0ff';
      // 中央胴体（縦長）
      ctx.fillRect(baseX - 2 * px, baseY - 4 * px, 4 * px, 8 * px);
      // コックピット
      ctx.fillStyle = '#0bf';
      ctx.fillRect(baseX - 2 * px, baseY - 3 * px, 4 * px, 2 * px);
      // 機首
      ctx.fillStyle = '#0ff';
      ctx.fillRect(baseX - 1 * px, baseY - 5 * px, 2 * px, px);
      // 翼（左右に広げる）
      ctx.fillRect(baseX - 4 * px, baseY - 1 * px, 2 * px, 4 * px);
      ctx.fillRect(baseX + 2 * px, baseY - 1 * px, 2 * px, 4 * px);
      // エンジン付近
      ctx.fillStyle = '#08f';
      ctx.fillRect(baseX - 2 * px, baseY + 2 * px, 4 * px, 2 * px);
      // 炎
      ctx.fillStyle = '#ff0';
      ctx.fillRect(baseX - px, baseY + 4 * px, 2 * px, px);
    }

    function spawnEnemy() {
      // 時間経過で速度と出現頻度を上げる
      const elapsedRatio = (60 - timeLeft) / 60;
      const baseSpeed = 0.5 + elapsedRatio * 1.0;

      let type;
      const r = Math.random();
      if (r < 0.4) type = ENEMY_TYPES[0];        // ゴブリン
      else if (r < 0.7) type = ENEMY_TYPES[1];   // スライム
      else if (r < 0.9) type = ENEMY_TYPES[2];   // スケルトン
      else type = ENEMY_TYPES[3];                // 魔王

      enemies.push({
        type: type.name,
        color: type.color,
        score: type.score,
        x: Math.random() * (canvas.width - 32) + 16,
        y: -16,
        vy: baseSpeed + Math.random() * 1.0,
        size: 12 + Math.random() * 4,
        hp: type.name === 'demon' ? 4 : 1
      });
    }

    // 解像度を上げた敵ドット絵
    function drawEnemy(e) {
      const bx = Math.round(e.x / px) * px;
      const by = Math.round(e.y / px) * px;
      const s  = Math.round(e.size / px) * px;

      if (e.type === 'goblin') {
        // 緑の頭と耳＋胴
        ctx.fillStyle = e.color;
        ctx.fillRect(bx - s / 2, by - s / 2, s, s * 0.7);        // 頭
        ctx.fillRect(bx - s / 2 - px, by - s / 2, px, px * 2);   // 左耳
        ctx.fillRect(bx + s / 2,       by - s / 2, px, px * 2);  // 右耳
        ctx.fillRect(bx - s / 3, by + s * 0.2, (2 * s) / 3, s * 0.3); // 胴
        // 目と口
        ctx.fillStyle = '#030';
        ctx.fillRect(bx - px, by - px, px, px);
        ctx.fillRect(bx,      by - px, px, px);
        ctx.fillStyle = '#090';
        ctx.fillRect(bx - px, by + px, 2 * px, px);
      } else if (e.type === 'slime') {
        // 半円形スライム
        ctx.fillStyle = e.color;
        ctx.fillRect(bx - s / 2, by - s / 4, s, s / 2);
        ctx.fillRect(bx - s / 3, by - s / 2, (2 * s) / 3, s / 4);
        ctx.fillStyle = '#055';
        ctx.fillRect(bx - px, by - px / 2, px, px);
        ctx.fillRect(bx,      by - px / 2, px, px);
      } else if (e.type === 'skeleton') {
        // 白い頭と胴
        ctx.fillStyle = '#eee';
        ctx.fillRect(bx - s / 2, by - s / 2, s, s * 0.7);        // 頭
        ctx.fillRect(bx - s / 4, by + s * 0.2, s / 2, s * 0.3);  // 胴
        // 目穴
        ctx.fillStyle = '#000';
        ctx.fillRect(bx - s / 6, by - s / 6, px, px);
        ctx.fillRect(bx + s / 6 - px, by - s / 6, px, px);
        // 口
        ctx.fillRect(bx - s / 6, by + s / 10, (2 * s) / 6, px);
      } else if (e.type === 'demon') {
        // 魔王：大きめ＋角
        ctx.fillStyle = e.color;
        ctx.fillRect(bx - s / 2, by - s / 2, s, s);
        // 角
        ctx.fillRect(bx - s / 2, by - s / 2 - px, px * 2, px);
        ctx.fillRect(bx + s / 2 - px * 2, by - s / 2 - px, px * 2, px);
        // 目
        ctx.fillStyle = '#ff0';
        ctx.fillRect(bx - px * 2, by - px, px, px);
        ctx.fillRect(bx + px,     by - px, px, px);
        // 口
        ctx.fillStyle = '#f00';
        ctx.fillRect(bx - px * 2, by + px * 2, px * 4, px);
      }
    }

    function shoot() {
      const cfg = getLevelConfig();
      bullets.push({
        x: player.x,
        y: player.y - 10,
        vy: cfg.speed,
        color: cfg.color
      });
    }

    function drawBullets() {
      bullets.forEach(b => {
        ctx.fillStyle = b.color;
        const bx = Math.round(b.x / px) * px;
        const by = Math.round(b.y / px) * px;
        ctx.fillRect(bx - px, by - 3 * px, 2 * px, 6 * px);
      });
    }

    function spawnHitEffect(x, y, color) {
      effects.push({
        x,
        y,
        life: 10,
        color
      });
    }

    function drawEffects() {
      effects.forEach(e => {
        ctx.fillStyle = e.color;
        const bx = Math.round(e.x / px) * px;
        const by = Math.round(e.y / px) * px;
        ctx.fillRect(bx - px, by - px, px, px);
        ctx.fillRect(bx,      by - px, px, px);
        ctx.fillRect(bx - px, by,      px, px);
        ctx.fillRect(bx,      by,      px, px);
      });
    }

    // タッチ操作（下端より少し上までに制限）
    function handleTouch(e) {
      if (!playing) return;
      if (e.touches && e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        const tx = e.touches[0].clientX - rect.left;
        const ty = e.touches[0].clientY - rect.top;
        player.x = Math.max(16, Math.min(canvas.width - 16, tx));
        player.y = Math.max(32, Math.min(canvas.height - 40, ty)); // 下に行き過ぎない
      }
      e.preventDefault();
    }
    canvas.addEventListener('touchstart', handleTouch, { passive: false });
    canvas.addEventListener('touchmove', handleTouch, { passive: false });

    // PCデバッグ用マウス操作
    canvas.addEventListener('mousemove', e => {
      if (!playing) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      player.x = Math.max(16, Math.min(canvas.width - 16, mx));
      player.y = Math.max(32, Math.min(canvas.height - 40, my));
    });

    let lastShotTime = 0;
    let lastSpawnTime = 0;

    function update(dt, now) {
      if (!playing) return;

      // 時間経過
      timeLeft -= dt;
      if (timeLeft < 0) timeLeft = 0;
      timeEl.textContent = timeLeft.toFixed(0);

      const elapsedRatio = (60 - timeLeft) / 60;

      // レベルに応じた連射間隔
      const shotInterval =
        BASE_SHOT_INTERVAL / (1 + (level - 1) * 0.35);
      if (now - lastShotTime > shotInterval) {
        shoot();
        lastShotTime = now;
      }

      // 敵出現間隔（だんだん短くなる）
      const spawnInterval = 900 - elapsedRatio * 450; // 900→450ms
      if (now - lastSpawnTime > spawnInterval) {
        if (enemies.length < 40) spawnEnemy();
        lastSpawnTime = now;
      }

      // 弾更新
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.y += b.vy;
        if (b.y < -20) bullets.splice(i, 1);
      }

      // 敵更新
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.y += e.vy;
        if (e.y > canvas.height + 20) enemies.splice(i, 1);
      }

      // エフェクト更新
      for (let i = effects.length - 1; i >= 0; i--) {
        const ef = effects[i];
        ef.life -= 1;
        if (ef.life <= 0) effects.splice(i, 1);
      }

      // 当たり判定
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        // 自機との衝突
        if (Math.abs(e.x - player.x) < 12 && Math.abs(e.y - player.y) < 12) {
          gameOver();
          return;
        }

        // 弾との衝突
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (Math.abs(e.x - b.x) < 10 && Math.abs(e.y - b.y) < 10) {
            bullets.splice(j, 1);
            e.hp -= 1;
            spawnHitEffect(e.x, e.y, '#ff8');
            if (e.hp <= 0) {
              score += e.score;
              scoreEl.textContent = score;
              enemies.splice(i, 1);

              // 撃破数カウント＆レベルアップ判定
              killCount++;
              const newLevel = Math.floor(killCount / 20) + 1;
              if (newLevel > level) {
                level = newLevel;
                levelEl.textContent = level;
                msgEl.textContent = 'LEVEL ' + level + '!';
                setTimeout(() => {
                  if (msgEl.textContent.startsWith('LEVEL')) {
                    msgEl.textContent = '';
                  }
                }, 1200);
              }
            }
            break;
          }
        }
      }

      if (timeLeft <= 0) {
        gameOver();
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 背景のスクロール星空
      ctx.fillStyle = '#060612';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#222233';
      for (let i = 0; i < 40; i++) {
        const x = (i * 29 + Math.floor(performance.now() / 40)) % canvas.width;
        const y = (i * 37 + Math.floor(performance.now() / 80)) % canvas.height;
        ctx.fillRect(Math.round(x / px) * px, Math.round(y / px) * px, px, px);
      }

      drawPlayer();
      drawBullets();
      enemies.forEach(drawEnemy);
      drawEffects();
    }

    function loop(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      if (playing) {
        update(dt, timestamp);
      }
      render();

      requestAnimationFrame(loop);
    }

    function gameOver() {
      playing = false;
      finalTimeEl.textContent = (60 - timeLeft).toFixed(1);
      finalScoreEl.textContent = score;

      if (score >= 1000) {
        resultMsgEl.textContent = '魔王討伐級！あなたは伝説のパイロットです。';
      } else if (score >= 600) {
        resultMsgEl.textContent = 'なかなかの腕前！高レベル維持を狙おう。';
      } else if (score >= 300) {
        resultMsgEl.textContent = 'まだまだ伸びしろあり。レベルアップを意識しよう。';
      } else {
        resultMsgEl.textContent = 'まずは敵に当たらないことと20体撃破を目指そう。';
      }

      gameOverScreen.classList.add('active');
    }

    function startGame() {
      resetGame();
      startScreen.classList.remove('active');
      gameOverScreen.classList.remove('active');
      playing = true;
      lastTime = performance.now();
    }

    startBtn.addEventListener('click', startGame);
    retryBtn.addEventListener('click', startGame);

    lastTime = performance.now();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
