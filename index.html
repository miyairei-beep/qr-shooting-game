<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ドット絵シューティング</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Mono", monospace;
      color: #fff;
      overflow: hidden;
    }
    #game-container {
      position: relative;
    }
    canvas {
      background: #101018;
      image-rendering: pixelated;
      width: 360px;
      height: 640px;
      border: 2px solid #444;
      display: block;
    }
    #ui-overlay {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      text-align: center;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
    #ui-top {
      display: flex;
      justify-content: space-between;
      padding: 0 8px;
      font-size: 14px;
    }
    #message-center {
      margin-top: 4px;
      font-size: 13px;
    }
    .screen {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 16px;
      z-index: 10;
    }
    .screen h1 {
      font-size: 24px;
      margin-bottom: 12px;
    }
    .screen p {
      font-size: 13px;
      line-height: 1.6;
      margin-bottom: 12px;
    }
    .btn {
      margin-top: 8px;
      padding: 8px 20px;
      border-radius: 999px;
      border: 1px solid #0ff;
      background: #022;
      color: #0ff;
      font-size: 14px;
      cursor: pointer;
      pointer-events: auto;
      transition: background 0.1s, transform 0.1s;
    }
    .btn:active {
      transform: translateY(1px);
      background: #044;
    }
    /* HARDボタンだけ薄い赤色 */
    #start-hard-btn,
    #retry-hard-btn {
      background: #402020;
      border-color: #f88;
      color: #ffdede;
    }
    #start-hard-btn:active,
    #retry-hard-btn:active {
      background: #5a2525;
    }

    #start-screen, #gameover-screen {
      display: none;
    }
    #start-screen.active, #gameover-screen.active {
      display: flex;
    }
    #hint {
      font-size: 11px;
      opacity: 0.8;
    }
    .mode-buttons {
      display: flex;
      gap: 8px;
      margin-top: 4px;
      flex-wrap: wrap;
      justify-content: center;
    }
    #levelup-banner {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 22px;
      color: #ff0;
      text-shadow: 0 0 8px #f80;
      pointer-events: none;
      opacity: 0;
      z-index: 5;
    }
    @keyframes levelup-pop {
      0% {
        transform: translateX(-50%) scale(0.4);
        opacity: 0;
      }
      20% {
        transform: translateX(-50%) scale(1.3);
        opacity: 1;
      }
      60% {
        transform: translateX(-50%) scale(1.0);
        opacity: 1;
      }
      100% {
        transform: translateX(-50%) scale(1.0);
        opacity: 0;
      }
    }
    #levelup-banner.show {
      animation: levelup-pop 0.9s ease-out forwards;
    }

    /* 完全制覇用の豪華表示 */
    #result-message {
      font-size: 13px;
      margin-top: 4px;
    }
    #result-message.clear {
      font-size: 22px;
      margin-top: 8px;
      color: #ffea7f;
      text-shadow: 0 0 10px #ff8, 0 0 14px #fa0;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="180" height="320"></canvas>

    <div id="ui-overlay">
      <div id="ui-top">
        <div>TIME: <span id="time">60</span>s</div>
        <div>LV: <span id="level">1</span></div>
        <div>SCORE: <span id="score">0</span></div>
      </div>
      <div id="message-center"></div>
    </div>

    <div id="levelup-banner">レベルUP!!!</div>

    <!-- タイトル画面 -->
    <div id="start-screen" class="screen active">
      <h1>ドット絵シューティング</h1>
      <p>
        ・縦画面・片手ドラッグ操作<br>
        ・20体撃破ごとにレベルアップ<br>
        ・EASY: ゆるめの敵配置（60秒）<br>
        ・NORMAL: 以前のハード相当（60秒）<br>
        ・HARD: 地獄級、100秒耐久
      </p>
      <p id="hint">
        画面をドラッグした位置に自機が移動します。<br>
        弾は自動で発射されます。
      </p>
      <div class="mode-buttons">
        <button id="start-easy-btn" class="btn">EASYで開始</button>
        <button id="start-normal-btn" class="btn">NORMALで開始</button>
        <button id="start-hard-btn" class="btn">HARDで開始</button>
      </div>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="gameover-screen" class="screen">
      <h1>RESULT</h1>
      <p>
        TIME: <span id="final-time">0</span>s<br>
        SCORE: <span id="final-score">0</span><br>
        LV: <span id="final-level">1</span><br>
        MODE: <span id="final-mode">EASY</span>
      </p>
      <p id="result-message"></p>
      <div class="mode-buttons">
        <button id="retry-easy-btn" class="btn">EASYで再挑戦</button>
        <button id="retry-normal-btn" class="btn">NORMALで再挑戦</button>
        <button id="retry-hard-btn" class="btn">HARDで再挑戦</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const timeEl = document.getElementById('time');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const msgEl = document.getElementById('message-center');
    const levelupBanner = document.getElementById('levelup-banner');

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startEasyBtn = document.getElementById('start-easy-btn');
    const startNormalBtn = document.getElementById('start-normal-btn');
    const startHardBtn = document.getElementById('start-hard-btn');
    const retryEasyBtn = document.getElementById('retry-easy-btn');
    const retryNormalBtn = document.getElementById('retry-normal-btn');
    const retryHardBtn = document.getElementById('retry-hard-btn');

    const finalTimeEl = document.getElementById('final-time');
    const finalScoreEl = document.getElementById('final-score');
    const finalLevelEl = document.getElementById('final-level');
    const finalModeEl = document.getElementById('final-mode');
    const resultMsgEl = document.getElementById('result-message');

    // 難易度ごとの設定
    const DIFFICULTY_CONFIG = {
      easy: {
        totalTime: 60,
        enemySpeedMul: 1.0,
        spawnBase: 900,
        spawnScale: 500,
        baseWave: 1,
        waveScale: 2,
        maxEnemies: 60,
        patterns: 'none'
      },
      normal: {
        totalTime: 60,
        enemySpeedMul: 1.3,
        spawnBase: 800,
        spawnScale: 550,
        baseWave: 1,
        waveScale: 3,
        maxEnemies: 90,
        patterns: 'medium'
      },
      hard: {
        totalTime: 100,
        enemySpeedMul: 1.6,
        spawnBase: 700,
        spawnScale: 700,
        baseWave: 2,
        waveScale: 5,
        maxEnemies: 120,
        patterns: 'hell'
      }
    };

    let difficulty = 'easy';

    let playing = false;
    let timeLeft = 60;
    let score = 0;
    let lastTime = 0;
    let level = 1;
    let killCount = 0;

    const player = {
      x: canvas.width / 2,
      y: canvas.height - 60,
      w: 12,
      h: 14
    };

    const bullets = [];
    const enemies = [];
    const particles = [];

    const px = 2;

    const LEVEL_CONFIG = [
      { color: '#ff0', speed: -3.0 },
      { color: '#0ff', speed: -3.8 },
      { color: '#f80', speed: -4.6 },
      { color: '#f0f', speed: -5.4 }
    ];
    const BASE_SHOT_INTERVAL = 180;

    function getLevelConfig() {
      const idx = Math.min(level - 1, LEVEL_CONFIG.length - 1);
      return LEVEL_CONFIG[idx];
    }

    const ENEMY_TYPES = [
      { name: 'goblin',   color: '#3f3', score: 20 },
      { name: 'slime',    color: '#6ff', score: 15 },
      { name: 'skeleton', color: '#fff', score: 25 },
      { name: 'demon',    color: '#f3f', score: 120 }
    ];

    function resetGame() {
      const cfg = DIFFICULTY_CONFIG[difficulty];
      timeLeft = cfg.totalTime;
      score = 0;
      level = 1;
      killCount = 0;
      timeEl.textContent = timeLeft;
      scoreEl.textContent = score;
      levelEl.textContent = level;
      bullets.length = 0;
      enemies.length = 0;
      particles.length = 0;
      player.x = canvas.width / 2;
      player.y = canvas.height - 60;
      lastTime = performance.now();
      msgEl.textContent = '';
      levelupBanner.classList.remove('show');
    }

    function drawPlayer() {
      const baseX = Math.round(player.x / px) * px;
      const baseY = Math.round(player.y / px) * px;

      ctx.fillStyle = '#0ff';
      ctx.fillRect(baseX - 2 * px, baseY - 4 * px, 4 * px, 8 * px);
      ctx.fillStyle = '#0bf';
      ctx.fillRect(baseX - 2 * px, baseY - 3 * px, 4 * px, 2 * px);
      ctx.fillStyle = '#0ff';
      ctx.fillRect(baseX - 1 * px, baseY - 5 * px, 2 * px, px);
      ctx.fillRect(baseX - 4 * px, baseY - 1 * px, 2 * px, 4 * px);
      ctx.fillRect(baseX + 2 * px, baseY - 1 * px, 2 * px, 4 * px);
      ctx.fillStyle = '#08f';
      ctx.fillRect(baseX - 2 * px, baseY + 2 * px, 4 * px, 2 * px);
      ctx.fillStyle = '#ff0';
      ctx.fillRect(baseX - px, baseY + 4 * px, 2 * px, px);
    }

    function spawnEnemy() {
      const cfg = DIFFICULTY_CONFIG[difficulty];
      const totalTime = cfg.totalTime;
      const elapsedRatio = (totalTime - timeLeft) / totalTime;

      let baseSpeed = (0.5 + elapsedRatio * 1.2) * cfg.enemySpeedMul;

      let type;
      const r = Math.random();
      if (r < 0.4) type = ENEMY_TYPES[0];
      else if (r < 0.7) type = ENEMY_TYPES[1];
      else if (r < 0.9) type = ENEMY_TYPES[2];
      else type = ENEMY_TYPES[3];

      const enemy = {
        type: type.name,
        color: type.color,
        score: type.score,
        x: Math.random() * (canvas.width - 32) + 16,
        y: -16,
        vy: baseSpeed + Math.random() * 1.4,
        vx: 0,
        size: 12 + Math.random() * 4,
        hp: type.name === 'demon' ? 4 : 1,
        pattern: 'straight',
        zigzagDir: Math.random() < 0.5 ? -1 : 1
      };

      if (cfg.patterns === 'medium' || cfg.patterns === 'hell') {
        const pr = Math.random();
        if (pr < 0.33) {
          enemy.pattern = 'diagonal';
          const mul = cfg.patterns === 'hell'
            ? (1.0 + elapsedRatio * 1.4)
            : (0.8 + elapsedRatio * 0.9);
          enemy.vx = (Math.random() < 0.5 ? -1 : 1) * mul;
        } else if (pr < 0.66) {
          enemy.pattern = 'meteor';
          const meteorMul = cfg.patterns === 'hell' ? 3.2 : 2.3;
          enemy.vy *= meteorMul;
        } else {
          enemy.pattern = 'zigzag';
          const zigMul = cfg.patterns === 'hell'
            ? (1.4 + elapsedRatio * 1.6)
            : (0.9 + elapsedRatio * 1.1);
          enemy.vx = enemy.zigzagDir * zigMul;
        }
      }

      enemies.push(enemy);
    }

    function drawEnemy(e) {
      const bx = Math.round(e.x / px) * px;
      const by = Math.round(e.y / px) * px;
      const s  = Math.round(e.size / px) * px;

      if (e.type === 'goblin') {
        ctx.fillStyle = e.color;
        ctx.fillRect(bx - s / 2, by - s / 2, s, s * 0.7);
        ctx.fillRect(bx - s / 2 - px, by - s / 2, px, px * 2);
        ctx.fillRect(bx + s / 2,       by - s / 2, px, px * 2);
        ctx.fillRect(bx - s / 3, by + s * 0.2, (2 * s) / 3, s * 0.3);
        ctx.fillStyle = '#030';
        ctx.fillRect(bx - px, by - px, px, px);
        ctx.fillRect(bx,      by - px, px, px);
        ctx.fillStyle = '#090';
        ctx.fillRect(bx - px, by + px, 2 * px, px);
      } else if (e.type === 'slime') {
        ctx.fillStyle = e.color;
        ctx.fillRect(bx - s / 2, by - s / 4, s, s / 2);
        ctx.fillRect(bx - s / 3, by - s / 2, (2 * s) / 3, s / 4);
        ctx.fillStyle = '#055';
        ctx.fillRect(bx - px, by - px / 2, px, px);
        ctx.fillRect(bx,      by - px / 2, px, px);
      } else if (e.type === 'skeleton') {
        ctx.fillStyle = '#eee';
        ctx.fillRect(bx - s / 2, by - s / 2, s, s * 0.7);
        ctx.fillRect(bx - s / 4, by + s * 0.2, s / 2, s * 0.3);
        ctx.fillStyle = '#000';
        ctx.fillRect(bx - s / 6, by - s / 6, px, px);
        ctx.fillRect(bx + s / 6 - px, by - s / 6, px, px);
        ctx.fillRect(bx - s / 6, by + s / 10, (2 * s) / 6, px);
      } else if (e.type === 'demon') {
        ctx.fillStyle = e.color;
        ctx.fillRect(bx - s / 2, by - s / 2, s, s);
        ctx.fillRect(bx - s / 2, by - s / 2 - px, px * 2, px);
        ctx.fillRect(bx + s / 2 - px * 2, by - s / 2 - px, px * 2, px);
        ctx.fillStyle = '#ff0';
        ctx.fillRect(bx - px * 2, by - px, px, px);
        ctx.fillRect(bx + px,     by - px, px, px);
        ctx.fillStyle = '#f00';
        ctx.fillRect(bx - px * 2, by + px * 2, px * 4, px);
      }
    }

    function shoot() {
      const cfg = getLevelConfig();
      bullets.push({
        x: player.x,
        y: player.y - 10,
        vy: cfg.speed,
        color: cfg.color
      });
    }

    function drawBullets() {
      bullets.forEach(b => {
        ctx.fillStyle = b.color;
        const bx = Math.round(b.x / px) * px;
        const by = Math.round(b.y / px) * px;
        ctx.fillRect(bx - px, by - 3 * px, 2 * px, 6 * px);
      });
    }

    function spawnExplosion(x, y, color) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 2.0,
          vy: (Math.random() - 0.5) * 2.0,
          life: 18,
          maxLife: 18
        });
      }
    }

    function drawParticles() {
      particles.forEach(p => {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = `rgba(255,220,160,${alpha.toFixed(2)})`;
        const bx = Math.round(p.x / px) * px;
        const by = Math.round(p.y / px) * px;
        ctx.fillRect(bx - px, by - px, 2 * px, 2 * px);
      });
    }

    function handleTouch(e) {
      if (!playing) return;
      if (e.touches && e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        const tx = e.touches[0].clientX - rect.left;
        const ty = e.touches[0].clientY - rect.top;
        player.x = Math.max(16, Math.min(canvas.width - 16, tx));
        player.y = Math.max(32, Math.min(canvas.height - 40, ty));
      }
      e.preventDefault();
    }
    canvas.addEventListener('touchstart', handleTouch, { passive: false });
    canvas.addEventListener('touchmove', handleTouch, { passive: false });

    canvas.addEventListener('mousemove', e => {
      if (!playing) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      player.x = Math.max(16, Math.min(canvas.width - 16, mx));
      player.y = Math.max(32, Math.min(canvas.height - 40, my));
    });

    let lastShotTime = 0;
    let lastSpawnTime = 0;

    function update(dt, now) {
      if (!playing) return;

      const cfg = DIFFICULTY_CONFIG[difficulty];
      timeLeft -= dt;
      if (timeLeft < 0) timeLeft = 0;
      timeEl.textContent = timeLeft.toFixed(0);

      const totalTime = cfg.totalTime;
      const elapsedRatio = (totalTime - timeLeft) / totalTime;

      const shotInterval =
        BASE_SHOT_INTERVAL / (1 + (level - 1) * 0.35);
      if (now - lastShotTime > shotInterval) {
        shoot();
        lastShotTime = now;
      }

      const spawnInterval =
        cfg.spawnBase - elapsedRatio * cfg.spawnScale;

      if (now - lastSpawnTime > spawnInterval) {
        const waveCount =
          cfg.baseWave + Math.floor(elapsedRatio * cfg.waveScale);
        for (let i = 0; i < waveCount; i++) {
          if (enemies.length < cfg.maxEnemies) spawnEnemy();
        }
        lastSpawnTime = now;
      }

      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.y += b.vy;
        if (b.y < -20) bullets.splice(i, 1);
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        if (DIFFICULTY_CONFIG[difficulty].patterns === 'none') {
          e.y += e.vy;
        } else {
          if (e.pattern === 'diagonal') {
            e.x += e.vx;
            e.y += e.vy;
          } else if (e.pattern === 'meteor') {
            e.y += e.vy;
          } else if (e.pattern === 'zigzag') {
            e.y += e.vy;
            e.x += e.vx;
            if (e.x < 10 || e.x > canvas.width - 10) {
              e.vx *= -1;
            }
          } else {
            e.y += e.vy;
          }
        }

        if (e.y > canvas.height + 20) enemies.splice(i, 1);
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 1;
        if (p.life <= 0) particles.splice(i, 1);
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        if (Math.abs(e.x - player.x) < 12 && Math.abs(e.y - player.y) < 12) {
          gameOver('hit');
          return;
        }

        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (Math.abs(e.x - b.x) < 10 && Math.abs(e.y - b.y) < 10) {
            bullets.splice(j, 1);
            e.hp -= 1;
            spawnExplosion(e.x, e.y, e.color);
            if (e.hp <= 0) {
              score += e.score;
              scoreEl.textContent = score;
              enemies.splice(i, 1);
              killCount++;

              const newLevel = Math.floor(killCount / 20) + 1;
              if (newLevel > level) {
                level = newLevel;
                levelEl.textContent = level;
                msgEl.textContent = 'LEVEL ' + level;
                levelupBanner.classList.remove('show');
                void levelupBanner.offsetWidth;
                levelupBanner.classList.add('show');
                setTimeout(() => {
                  if (msgEl.textContent.startsWith('LEVEL')) {
                    msgEl.textContent = '';
                  }
                }, 1400);
              }
            }
            break;
          }
        }
      }

      if (timeLeft <= 0) {
        gameOver('clear');
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#060612';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#222233';
      for (let i = 0; i < 40; i++) {
        const x = (i * 29 + Math.floor(performance.now() / 40)) % canvas.width;
        const y = (i * 37 + Math.floor(performance.now() / 80)) % canvas.height;
        ctx.fillRect(Math.round(x / px) * px, Math.round(y / px) * px, px, px);
      }

      drawPlayer();
      drawBullets();
      enemies.forEach(drawEnemy);
      drawParticles();
    }

    function loop(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      if (playing) {
        update(dt, timestamp);
      }
      render();

      requestAnimationFrame(loop);
    }

    function gameOver(reason) {
      playing = false;
      const cfg = DIFFICULTY_CONFIG[difficulty];
      const totalTime = cfg.totalTime;
      finalTimeEl.textContent = (totalTime - timeLeft).toFixed(1);
      finalScoreEl.textContent = score;
      finalLevelEl.textContent = level;
      finalModeEl.textContent =
        difficulty === 'hard' ? 'HARD'
        : difficulty === 'normal' ? 'NORMAL'
        : 'EASY';

      // 豪華な「完全制覇！！」表示
      resultMsgEl.classList.remove('clear');

      if (reason === 'clear') {
        resultMsgEl.textContent = '完全制覇！！';
        resultMsgEl.classList.add('clear');
      } else {
        if (score >= 1000) {
          resultMsgEl.textContent = '魔王討伐級！あなたは伝説のパイロットです。';
        } else if (score >= 600) {
          resultMsgEl.textContent = 'なかなかの腕前！高レベル維持を狙おう。';
        } else if (score >= 300) {
          resultMsgEl.textContent = 'まだまだ伸びしろあり。レベルアップを意識しよう。';
        } else {
          resultMsgEl.textContent = 'まずは敵に当たらないことと20体撃破を目指そう。';
        }
      }

      gameOverScreen.classList.add('active');
    }

    function startGame(selectedMode) {
      difficulty = selectedMode;
      resetGame();
      startScreen.classList.remove('active');
      gameOverScreen.classList.remove('active');
      playing = true;
      lastTime = performance.now();
      msgEl.textContent =
        difficulty === 'hard'
          ? 'HARD MODE'
          : difficulty === 'normal'
            ? 'NORMAL MODE'
            : '';
    }

    startEasyBtn.addEventListener('click', () => startGame('easy'));
    startNormalBtn.addEventListener('click', () => startGame('normal'));
    startHardBtn.addEventListener('click', () => startGame('hard'));
    retryEasyBtn.addEventListener('click', () => startGame('easy'));
    retryNormalBtn.addEventListener('click', () => startGame('normal'));
    retryHardBtn.addEventListener('click', () => startGame('hard'));

    lastTime = performance.now();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
