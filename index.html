<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>1分ドット絵シューティング</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none; /* モバイルでのダブルタップズーム等を抑制 */
    }
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Mono", monospace;
      color: #fff;
      overflow: hidden;
    }
    #game-container {
      position: relative;
    }
    canvas {
      background: #101018;
      image-rendering: pixelated;
      width: 360px;   /* 表示サイズ（CSS） */
      height: 640px;
      border: 2px solid #444;
      display: block;
    }
    #ui-overlay {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      text-align: center;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
    #ui-top {
      display: flex;
      justify-content: space-between;
      padding: 0 16px;
      font-size: 14px;
    }
    #message-center {
      margin-top: 8px;
      font-size: 12px;
    }
    .screen {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 16px;
      z-index: 10;
    }
    .screen h1 {
      font-size: 24px;
      margin-bottom: 12px;
    }
    .screen p {
      font-size: 13px;
      line-height: 1.6;
      margin-bottom: 12px;
    }
    .btn {
      margin-top: 8px;
      padding: 8px 20px;
      border-radius: 999px;
      border: 1px solid #0ff;
      background: #022;
      color: #0ff;
      font-size: 14px;
      cursor: pointer;
      pointer-events: auto;
      transition: background 0.1s, transform 0.1s;
    }
    .btn:active {
      transform: translateY(1px);
      background: #044;
    }
    #start-screen, #gameover-screen {
      display: none;
    }
    #start-screen.active, #gameover-screen.active {
      display: flex;
    }
    #hint {
      font-size: 11px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="180" height="320"></canvas>

    <div id="ui-overlay">
      <div id="ui-top">
        <div>TIME: <span id="time">60</span>s</div>
        <div>SCORE: <span id="score">0</span></div>
      </div>
      <div id="message-center"></div>
    </div>

    <!-- タイトル画面 -->
    <div id="start-screen" class="screen active">
      <h1>1分ドット絵シューティング</h1>
      <p>
        ・縦画面・片手ドラッグ操作<br>
        ・自機はSFジェット機<br>
        ・ゴブリン / スライム / スケルトン / 魔王 を撃破<br>
        ・制限時間は 1 分
      </p>
      <p id="hint">画面をタッチした位置に自機が移動します。弾は自動で発射されます。</p>
      <button id="start-btn" class="btn">ゲーム開始</button>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="gameover-screen" class="screen">
      <h1>GAME OVER</h1>
      <p>TIME: <span id="final-time">0</span>s<br> SCORE: <span id="final-score">0</span></p>
      <p id="result-message"></p>
      <button id="retry-btn" class="btn">もう一度プレイ</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // ピクセルアートをくっきり表示
    ctx.imageSmoothingEnabled = false;

    const timeEl = document.getElementById('time');
    const scoreEl = document.getElementById('score');
    const msgEl = document.getElementById('message-center');

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startBtn = document.getElementById('start-btn');
    const retryBtn = document.getElementById('retry-btn');
    const finalTimeEl = document.getElementById('final-time');
    const finalScoreEl = document.getElementById('final-score');
    const resultMsgEl = document.getElementById('result-message');

    // ゲーム状態
    let playing = false;
    let timeLeft = 60;
    let score = 0;
    let lastTime = 0;

    // 自機
    const player = {
      x: canvas.width / 2,
      y: canvas.height - 40,
      w: 10,
      h: 12
    };

    // 弾と敵
    const bullets = [];
    const enemies = [];
    const effects = []; // 簡易ヒットエフェクト

    const px = 2; // ドット粒度

    // 敵タイプ
    const ENEMY_TYPES = [
      { name: 'goblin',   color: '#3f3', score: 20 },
      { name: 'slime',    color: '#6ff', score: 15 },
      { name: 'skeleton', color: '#fff', score: 25 },
      { name: 'demon',    color: '#f3f', score: 100 }
    ];

    function resetGame() {
      timeLeft = 60;
      score = 0;
      timeEl.textContent = timeLeft;
      scoreEl.textContent = score;
      bullets.length = 0;
      enemies.length = 0;
      effects.length = 0;
      player.x = canvas.width / 2;
      player.y = canvas.height - 40;
      lastTime = performance.now();
      msgEl.textContent = '';
    }

    // 自機描画（SFっぽいジェット、シルエット重視でデフォルメ）
    function drawPlayer() {
      const baseX = Math.round(player.x / px) * px;
      const baseY = Math.round(player.y / px) * px;

      // 機体色
      ctx.fillStyle = '#0ff';
      // 胴体
      ctx.fillRect(baseX - 2 * px, baseY - 3 * px, 4 * px, 6 * px);
      // 機首
      ctx.fillRect(baseX - 1 * px, baseY - 4 * px, 2 * px, 1 * px);
      // 翼
      ctx.fillRect(baseX - 3 * px, baseY - 1 * px, 1 * px, 3 * px);
      ctx.fillRect(baseX + 2 * px, baseY - 1 * px, 1 * px, 3 * px);
      // エンジン
      ctx.fillStyle = '#08f';
      ctx.fillRect(baseX - px, baseY + 2 * px, 2 * px, px);
      // 炎
      ctx.fillStyle = '#ff0';
      ctx.fillRect(baseX - px, baseY + 3 * px, 2 * px, px);
    }

    function spawnEnemy() {
      // 時間経過で少しずつ出現頻度と速度を上げる
      const elapsedRatio = (60 - timeLeft) / 60; // 0〜1
      const baseSpeed = 0.4 + elapsedRatio * 0.8;

      let type;
      const r = Math.random();
      if (r < 0.4) type = ENEMY_TYPES[0];        // ゴブリン
      else if (r < 0.7) type = ENEMY_TYPES[1];   // スライム
      else if (r < 0.9) type = ENEMY_TYPES[2];   // スケルトン
      else type = ENEMY_TYPES[3];                // 魔王

      enemies.push({
        type: type.name,
        color: type.color,
        score: type.score,
        x: Math.random() * (canvas.width - 20) + 10,
        y: -10,
        vy: baseSpeed + Math.random() * 0.8,
        size: 8 + Math.random() * 4,
        hp: type.name === 'demon' ? 3 : 1
      });
    }

    function drawEnemy(e) {
      ctx.fillStyle = e.color;
      const bx = Math.round(e.x / px) * px;
      const by = Math.round(e.y / px) * px;
      const s  = Math.round(e.size / px) * px;

      if (e.type === 'goblin') {
        // 頭+耳
        ctx.fillRect(bx - s / 2, by - s / 2, s, s);
        ctx.fillRect(bx - s / 2 - px, by - s / 2, px, px);
        ctx.fillRect(bx + s / 2,     by - s / 2, px, px);
        // 目
        ctx.fillStyle = '#030';
        ctx.fillRect(bx - px, by - px, px, px);
        ctx.fillRect(bx,      by - px, px, px);
      } else if (e.type === 'slime') {
        ctx.fillStyle = e.color;
        ctx.fillRect(bx - s / 2, by - s / 4, s, s / 2);
        ctx.fillRect(bx - s / 4, by - s / 2, s / 2, s / 4);
        ctx.fillStyle = '#055';
        ctx.fillRect(bx - px, by - px / 2, px, px);
        ctx.fillRect(bx,      by - px / 2, px, px);
      } else if (e.type === 'skeleton') {
        ctx.fillStyle = '#eee';
        ctx.fillRect(bx - s / 3, by - s / 3, (2 * s) / 3, (2 * s) / 3);
        // 目穴
        ctx.fillStyle = '#000';
        ctx.fillRect(bx - s / 6, by - s / 8, px, px);
        ctx.fillRect(bx + s / 6 - px, by - s / 8, px, px);
        // 口
        ctx.fillRect(bx - s / 6, by + s / 8, (2 * s) / 6, px);
      } else if (e.type === 'demon') {
        // 魔王ぽい大きめシルエット
        ctx.fillStyle = e.color;
        ctx.fillRect(bx - s / 2, by - s / 2, s, s);
        // 角
        ctx.fillRect(bx - s / 2, by - s / 2 - px, px, px);
        ctx.fillRect(bx + s / 2 - px, by - s / 2 - px, px, px);
        // 目
        ctx.fillStyle = '#ff0';
        ctx.fillRect(bx - px, by - px, px, px);
        ctx.fillRect(bx,      by - px, px, px);
      }
    }

    function shoot() {
      bullets.push({
        x: player.x,
        y: player.y - 8,
        vy: -3
      });
    }

    function drawBullets() {
      ctx.fillStyle = '#ff0';
      bullets.forEach(b => {
        const bx = Math.round(b.x / px) * px;
        const by = Math.round(b.y / px) * px;
        ctx.fillRect(bx - px, by - 2 * px, 2 * px, 4 * px);
      });
    }

    function spawnHitEffect(x, y, color) {
      effects.push({
        x,
        y,
        life: 10,
        color
      });
    }

    function drawEffects() {
      effects.forEach(e => {
        ctx.fillStyle = e.color;
        const bx = Math.round(e.x / px) * px;
        const by = Math.round(e.y / px) * px;
        ctx.fillRect(bx - px, by - px, px, px);
        ctx.fillRect(bx,      by - px, px, px);
        ctx.fillRect(bx - px, by,      px, px);
        ctx.fillRect(bx,      by,      px, px);
      });
    }

    // タッチ操作
    function handleTouch(e) {
      if (!playing) return;
      if (e.touches && e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        const tx = e.touches[0].clientX - rect.left;
        const ty = e.touches[0].clientY - rect.top;
        player.x = Math.max(12, Math.min(canvas.width - 12, tx));
        player.y = Math.max(16, Math.min(canvas.height - 16, ty));
      }
      e.preventDefault();
    }
    canvas.addEventListener('touchstart', handleTouch, { passive: false });
    canvas.addEventListener('touchmove', handleTouch, { passive: false });

    // PCデバッグ用マウス操作（任意）
    canvas.addEventListener('mousemove', e => {
      if (!playing) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      player.x = Math.max(12, Math.min(canvas.width - 12, mx));
      player.y = Math.max(16, Math.min(canvas.height - 16, my));
    });

    // メインループ関連
    let lastShotTime = 0;
    let lastSpawnTime = 0;

    function update(dt, now) {
      if (!playing) return;

      // 時間経過
      timeLeft -= dt;
      if (timeLeft < 0) timeLeft = 0;
      timeEl.textContent = timeLeft.toFixed(0);

      // 自動ショット（0.18秒ごと）
      if (now - lastShotTime > 180) {
        shoot();
        lastShotTime = now;
      }

      // 敵出現（難易度に応じて間隔を短く）
      const elapsedRatio = (60 - timeLeft) / 60;
      const spawnInterval = 900 - elapsedRatio * 400; // 900〜500ms
      if (now - lastSpawnTime > spawnInterval) {
        spawnEnemy();
        lastSpawnTime = now;
      }

      // 弾更新
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.y += b.vy;
        if (b.y < -10) bullets.splice(i, 1);
      }

      // 敵更新
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.y += e.vy;
        if (e.y > canvas.height + 20) enemies.splice(i, 1);
      }

      // エフェクト更新
      for (let i = effects.length - 1; i >= 0; i--) {
        const ef = effects[i];
        ef.life -= 1;
        if (ef.life <= 0) effects.splice(i, 1);
      }

      // 当たり判定
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        // 自機と衝突
        if (Math.abs(e.x - player.x) < 10 && Math.abs(e.y - player.y) < 10) {
          gameOver();
          return;
        }

        // 弾との衝突
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (Math.abs(e.x - b.x) < 8 && Math.abs(e.y - b.y) < 8) {
            bullets.splice(j, 1);
            e.hp -= 1;
            spawnHitEffect(e.x, e.y, '#ff8');
            if (e.hp <= 0) {
              score += e.score;
              scoreEl.textContent = score;
              enemies.splice(i, 1);
            }
            break;
          }
        }
      }

      // 制限時間終了
      if (timeLeft <= 0) {
        gameOver();
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 背景の簡易スクロール星空
      ctx.fillStyle = '#060612';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#222233';
      for (let i = 0; i < 30; i++) {
        const x = (i * 23 + Math.floor(performance.now() / 40)) % canvas.width;
        const y = (i * 37 + Math.floor(performance.now() / 80)) % canvas.height;
        ctx.fillRect(Math.round(x / px) * px, Math.round(y / px) * px, px, px);
      }

      drawPlayer();
      drawBullets();
      enemies.forEach(drawEnemy);
      drawEffects();
    }

    function loop(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      if (playing) {
        update(dt, timestamp);
      }
      render();

      requestAnimationFrame(loop);
    }

    function gameOver() {
      playing = false;
      finalTimeEl.textContent = (60 - timeLeft).toFixed(1);
      finalScoreEl.textContent = score;

      if (score >= 800) {
        resultMsgEl.textContent = '魔王討伐級！あなたは伝説のパイロットです。';
      } else if (score >= 400) {
        resultMsgEl.textContent = 'なかなかの腕前！魔王討伐を目指そう。';
      } else if (score >= 200) {
        resultMsgEl.textContent = 'まだまだ伸びしろあり。敵の動きをよく見よう。';
      } else {
        resultMsgEl.textContent = 'まずは敵に当たらないことを意識しよう。';
      }

      gameOverScreen.classList.add('active');
    }

    function startGame() {
      resetGame();
      startScreen.classList.remove('active');
      gameOverScreen.classList.remove('active');
      playing = true;
      lastTime = performance.now();
    }

    startBtn.addEventListener('click', startGame);
    retryBtn.addEventListener('click', startGame);

    // 最初のフレーム開始
    lastTime = performance.now();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
